<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        * 什么是原型
        * 实例对象中有__proto__这个属性,叫原型,也是一个对象,这个属性时给浏览器使用的,不是标准属性
        * 构造函数中有prototype这个属性,叫原型.也是一个对象,这个属性是给程序员使用的
        * 两者都可以叫原型对象
        *
        * 实例对象中的__proto__指向创建该实例对象的构造函数中的prototype
        * 构造函数里的prototype里面的属性和方法可以通过实例对象.直接调用,原因是指向了这个原型对象
        *
        * 本身在构造函数中定义的属性和方法,当实例化对象的时候,实例对象的属性和方法都是在自己的内存空间存在的,如果是多个对象,这写属性和方法都在一个单独的空间存在,浪费内存空间,所以为了数据共享,就把想要共享的属性和方法都写在原型对象中,达到了数据共享,节省了内存空间
        *
        * 原型的作用之一:数据共享,节省内存空间
        *
        * 原型的写法:
        * 构造函数.prototype.属性=值
        * 构造函数.prototype.方法=值====>函数.prototype,函数也是对象,所以里面也有__proto__
        *
        * 实例对象里面只有__proto__
        *
        * 简单的原型写法:(需要添加的方法很多)
        * 构造函数.prototype={}
        *
        * 缺陷:这种写法原型直接指向{}---->就是一个对象,没有构造器
        * 所以要手动加上构造器
        *
        * 通过原型对象为内置对象添加属性或者方法--->原因:
        * 系统的内置对象的属性和方法可能不能满足现在的需求,所以,可以通过原型的方式加入属性或者方法,方便开发
        *
        * 为内置对象的原型添加属性和方法,那么这个内置对象的实例对象,就可以直接调用了
        * String.prototype.方法=匿名函数;
        * var str ="哈哈";
        * str.方法();--->实例对象可以直接调用原型中的这个属性或者方法
        *
        * var str ="字符串";//这可以看成是一个实例对象
        * str.init(); //此时实例对象调用的方法,这个属性或者方法在系统内置对象中肯定是不存在的,正常情况下属性和方法都是在构造函数或者构造函数的原型当中
        *
        *
        *
        * */



        //实例对象中没有方法,但是能够使用
        //document是属性,也是一个对象
        //write();是方法
        window.document.write("哈哈");

        function Person(name, age) {
            this.name = name;
            this.age = age;
            this.eat = function () {
                console.log("我是方法");
            }
        }

        let a = new Person("小红", 18);
        let b = new Person("小明", 18);
        console.dir(Person);
        console.dir(a);
        console.dir(b);


    </script>
</body>
</html>